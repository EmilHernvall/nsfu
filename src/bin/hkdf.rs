/// Implementation of the sample computations on https://tls13.ulfheim.net/
/// as a sanity check on hkdf usage

use ring::{aead::{self, Aad}, hkdf};

use nsfu::key_schedule::*;

fn main() {
    let shared_secret = [
        0xdf, 0x4a, 0x29, 0x1b, 0xaa, 0x1e, 0xb7, 0xcf,
        0xa6, 0x93, 0x4b, 0x29, 0xb4, 0x74, 0xba, 0xad,
        0x26, 0x97, 0xe2, 0x9f, 0x1f, 0x92, 0x0d, 0xcc,
        0x77, 0xc8, 0xa0, 0xa0, 0x88, 0x44, 0x76, 0x24,
    ];

    let hello_hash = [
        0xda, 0x75, 0xce, 0x11, 0x39, 0xac, 0x80, 0xda,
        0xe4, 0x04, 0x4d, 0xa9, 0x32, 0x35, 0x0c, 0xf6,
        0x5c, 0x97, 0xcc, 0xc9, 0xe3, 0x3f, 0x1e, 0x6f,
        0x7d, 0x2d, 0x4b, 0x18, 0xb7, 0x36, 0xff, 0xd5,
    ];

    let handshake_hash = hex::decode("22844b930e5e0a59a09d5ac35fc032fc91163b193874a265236e568077378d8b").unwrap();

    let handshake_schedule = HandshakeKeySchedule::derive(
        &shared_secret,
        &hello_hash,
    ).unwrap();

    let mut application_schedule =
        handshake_schedule.derive_application_schedule(handshake_hash).unwrap();

    let mut client_message = vec![0x70, 0x69, 0x6e, 0x67, 0x17];

    application_schedule.client_application_key.seal_in_place_append_tag(
        Aad::from(vec![0x17,0x03,0x03,0x00,0x15]),
        &mut client_message,
    ).unwrap();

    dbg!(hex::encode(client_message));

    let mut server_message = vec![
        0x37, 0x0e, 0x5f, 0x16, 0x8a,
        0xfa, 0x7f, 0xb1, 0x6b, 0x66, 0x3e, 0xcd, 0xfc, 0xa3, 0xdb, 0xb8, 0x19, 0x31, 0xa9, 0x0c, 0xa7,
    ];

    // only succeeds when key schedule is modified to set the iv seq to 1
    let server_message = application_schedule.server_application_key.open_in_place(
        Aad::from(vec![0x17,0x03,0x03,0x00,0x15]),
        &mut server_message,
    ).unwrap();

    dbg!(hex::encode(server_message));
}
